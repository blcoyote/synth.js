/**
 * PresetPanel Component Tests
 * 
 * Tests preset dropdown rendering, factory vs user presets,
 * save/load/delete operations, export/import functionality,
 * and onPresetLoad callback
 */

import { describe, it, expect, beforeEach, vi } from 'vitest';
import { render, screen, fireEvent } from '@testing-library/react';
import { PresetPanel } from '../../../../src/synth-v2/components/PresetPanel';
import { SynthProvider } from '../../../../src/synth-v2/context/SynthContext';
import type { SynthEngine } from '../../../../src/synth-v2/core/SynthEngine';
import type { PresetManager } from '../../../../src/synth-v2/core/PresetManager';
import type { PresetData } from '../../../../src/synth-v2/core/PresetManager';

// Mock factory presets module
vi.mock('../../../../src/synth-v2/core/FactoryPresets', () => ({
  FACTORY_PRESETS: [
    {
      name: 'Init',
      author: 'Factory',
      description: 'Clean starting point',
      oscillators: {
        1: { enabled: true, waveform: 'sine', octave: 0, detune: 0, volume: 0.8, pan: 0, fmEnabled: false, fmDepth: 0 },
        2: { enabled: false, waveform: 'sine', octave: 0, detune: 0, volume: 0.5, pan: 0, fmEnabled: false, fmDepth: 0 },
        3: { enabled: false, waveform: 'sine', octave: 0, detune: 0, volume: 0.5, pan: 0, fmEnabled: false, fmDepth: 0 },
      },
      envelopes: {
        1: { attack: 0.01, decay: 0.1, sustain: 0.7, release: 0.3 },
        2: { attack: 0.01, decay: 0.1, sustain: 0.7, release: 0.3 },
        3: { attack: 0.01, decay: 0.1, sustain: 0.7, release: 0.3 },
      },
    },
    {
      name: 'Brass',
      author: 'Factory',
      description: 'Warm brass sound',
      oscillators: {
        1: { enabled: true, waveform: 'sawtooth', octave: 0, detune: 0, volume: 0.8, pan: 0, fmEnabled: false, fmDepth: 0 },
        2: { enabled: true, waveform: 'square', octave: -1, detune: -7, volume: 0.6, pan: 0, fmEnabled: false, fmDepth: 0 },
        3: { enabled: false, waveform: 'sine', octave: 0, detune: 0, volume: 0.5, pan: 0, fmEnabled: false, fmDepth: 0 },
      },
      envelopes: {
        1: { attack: 0.02, decay: 0.15, sustain: 0.6, release: 0.5 },
        2: { attack: 0.02, decay: 0.15, sustain: 0.6, release: 0.5 },
        3: { attack: 0.01, decay: 0.1, sustain: 0.7, release: 0.3 },
      },
    },
  ],
}));

describe('PresetPanel', () => {
  let mockPresetManager: PresetManager;
  let mockEngine: SynthEngine;
  let onPresetLoad: () => void;

  function createMockPresetManager(): PresetManager {
    const userPresetsStorage: Map<string, PresetData> = new Map();

    return {
      getCurrentPreset: vi.fn(() => ({
        name: 'Current',
        author: 'User',
        description: 'Current state',
        oscillators: {
          1: { enabled: true, waveform: 'sine', octave: 0, detune: 0, volume: 0.8, pan: 0, fmEnabled: false, fmDepth: 0 },
          2: { enabled: false, waveform: 'sine', octave: 0, detune: 0, volume: 0.5, pan: 0, fmEnabled: false, fmDepth: 0 },
          3: { enabled: false, waveform: 'sine', octave: 0, detune: 0, volume: 0.5, pan: 0, fmEnabled: false, fmDepth: 0 },
        },
        envelopes: {
          1: { attack: 0.01, decay: 0.1, sustain: 0.7, release: 0.3 },
          2: { attack: 0.01, decay: 0.1, sustain: 0.7, release: 0.3 },
          3: { attack: 0.01, decay: 0.1, sustain: 0.7, release: 0.3 },
        },
      })),
      loadPreset: vi.fn(),
      savePreset: vi.fn((name: string) => {
        const preset: PresetData = {
          name,
          author: 'User',
          description: '',
          oscillators: {
            1: { enabled: true, waveform: 'sine', octave: 0, detune: 0, volume: 0.8, pan: 0, fmEnabled: false, fmDepth: 0 },
            2: { enabled: false, waveform: 'sine', octave: 0, detune: 0, volume: 0.5, pan: 0, fmEnabled: false, fmDepth: 0 },
            3: { enabled: false, waveform: 'sine', octave: 0, detune: 0, volume: 0.5, pan: 0, fmEnabled: false, fmDepth: 0 },
          },
          envelopes: {
            1: { attack: 0.01, decay: 0.1, sustain: 0.7, release: 0.3 },
            2: { attack: 0.01, decay: 0.1, sustain: 0.7, release: 0.3 },
            3: { attack: 0.01, decay: 0.1, sustain: 0.7, release: 0.3 },
          },
        };
        userPresetsStorage.set(name, preset);
      }),
      getUserPreset: vi.fn((name: string) => userPresetsStorage.get(name) || null),
      getUserPresetNames: vi.fn(() => Array.from(userPresetsStorage.keys()).sort()),
      deletePreset: vi.fn((name: string) => {
        const deleted = userPresetsStorage.delete(name);
        return deleted;
      }),
      exportPreset: vi.fn((preset: PresetData) => JSON.stringify(preset, null, 2)),
      importPreset: vi.fn((json: string) => JSON.parse(json) as PresetData),
    } as any;
  }

  function createMockSynthEngine(presetManager?: PresetManager): SynthEngine {
    const pm = presetManager || createMockPresetManager();
    return {
      isInitialized: () => true,
      getPresetManager: () => pm,
    } as any;
  }

  function renderWithContext(component: React.ReactElement, engine?: SynthEngine) {
    const mockEngine = engine || createMockSynthEngine();
    return render(
      <SynthProvider engine={mockEngine}>
        {component}
      </SynthProvider>
    );
  }

  beforeEach(() => {
    mockPresetManager = createMockPresetManager();
    mockEngine = createMockSynthEngine(mockPresetManager);
    onPresetLoad = vi.fn();

    // Mock window.confirm and window.alert
    vi.spyOn(window, 'confirm').mockReturnValue(true);
    vi.spyOn(window, 'alert').mockImplementation(() => {});

    // Mock URL.createObjectURL and URL.revokeObjectURL
    global.URL.createObjectURL = vi.fn(() => 'mock-url');
    global.URL.revokeObjectURL = vi.fn();

    // Mock FileReader
    global.FileReader = class MockFileReader {
      onload: ((event: ProgressEvent<FileReader>) => void) | null = null;
      readAsText(file: Blob) {
        setTimeout(() => {
          if (this.onload) {
            const event = {
              target: {
                result: '{"name":"Imported","author":"User","description":"","oscillators":{},"envelopes":{}}',
              },
            } as any;
            this.onload(event);
          }
        }, 0);
      }
    } as any;
  });

  describe('Rendering', () => {
    it('should render preset panel with title', () => {
      renderWithContext(<PresetPanel />);
      
      expect(screen.getByText('Presets')).toBeInTheDocument();
    });

    it('should render preset selector dropdown', () => {
      renderWithContext(<PresetPanel />);
      
      const select = screen.getByRole('combobox');
      expect(select).toBeInTheDocument();
      expect(screen.getByText('Load Preset')).toBeInTheDocument();
    });

    it('should render default option', () => {
      renderWithContext(<PresetPanel />);
      
      expect(screen.getByText('-- Select Preset --')).toBeInTheDocument();
    });

    it('should render action buttons', () => {
      renderWithContext(<PresetPanel />);
      
      expect(screen.getByText('Save Current')).toBeInTheDocument();
      expect(screen.getByText('Export')).toBeInTheDocument();
      expect(screen.getByText('Import')).toBeInTheDocument();
    });
  });

  describe('Factory Presets', () => {
    it('should render factory presets optgroup', () => {
      const { container } = renderWithContext(<PresetPanel />);
      
      const optgroup = container.querySelector('optgroup[label="Factory Presets"]');
      expect(optgroup).toBeInTheDocument();
    });

    it('should list all factory presets', () => {
      renderWithContext(<PresetPanel />);
      
      expect(screen.getByText('Init')).toBeInTheDocument();
      expect(screen.getByText('Brass')).toBeInTheDocument();
    });

    it('should load factory preset when selected', () => {
      renderWithContext(<PresetPanel onPresetLoad={onPresetLoad} />);
      
      const select = screen.getByRole('combobox');
      fireEvent.change(select, { target: { value: 'Init' } });
      
      expect(mockPresetManager.loadPreset).toHaveBeenCalledWith(
        expect.objectContaining({ name: 'Init' })
      );
    });

    it('should call onPresetLoad callback when factory preset loaded', () => {
      renderWithContext(<PresetPanel onPresetLoad={onPresetLoad} />);
      
      const select = screen.getByRole('combobox');
      fireEvent.change(select, { target: { value: 'Brass' } });
      
      expect(onPresetLoad).toHaveBeenCalledTimes(1);
    });

    it('should update selected preset state', () => {
      renderWithContext(<PresetPanel />);
      
      const select = screen.getByRole('combobox') as HTMLSelectElement;
      fireEvent.change(select, { target: { value: 'Init' } });
      
      expect(select.value).toBe('Init');
    });
  });

  describe('User Presets', () => {
    it('should not render user presets optgroup when no user presets exist', () => {
      renderWithContext(<PresetPanel />);
      
      const optgroups = screen.getAllByRole('group');
      expect(optgroups).toHaveLength(1); // Only Factory Presets
    });

    it('should render user presets optgroup after saving a preset', () => {
      renderWithContext(<PresetPanel />);
      
      // Save a preset through the UI
      fireEvent.click(screen.getByText('Save Current'));
      const input = screen.getByPlaceholderText('Preset name...');
      fireEvent.change(input, { target: { value: 'My Sound' } });
      const saveButtons = screen.getAllByText('Save');
      fireEvent.click(saveButtons[saveButtons.length - 1]);
      
      // Now check for user presets section
      const container = screen.getByText('Presets').closest('.preset-panel');
      expect(container).toHaveTextContent('Your Presets');
    });

    it('should list user presets in dropdown after saving', () => {
      renderWithContext(<PresetPanel />);
      
      // Save two presets
      fireEvent.click(screen.getByText('Save Current'));
      let input = screen.getByPlaceholderText('Preset name...');
      fireEvent.change(input, { target: { value: 'My Sound' } });
      let saveButtons = screen.getAllByText('Save');
      fireEvent.click(saveButtons[saveButtons.length - 1]);
      
      fireEvent.click(screen.getByText('Save Current'));
      input = screen.getByPlaceholderText('Preset name...');
      fireEvent.change(input, { target: { value: 'Bass Patch' } });
      saveButtons = screen.getAllByText('Save');
      fireEvent.click(saveButtons[saveButtons.length - 1]);
      
      // Check both are listed
      expect(screen.getByText('Bass Patch')).toBeInTheDocument();
      expect(screen.getByText('My Sound')).toBeInTheDocument();
    });

    it('should load user preset when selected', () => {
      renderWithContext(<PresetPanel onPresetLoad={onPresetLoad} />);
      
      // First save a preset
      fireEvent.click(screen.getByText('Save Current'));
      const input = screen.getByPlaceholderText('Preset name...');
      fireEvent.change(input, { target: { value: 'My Sound' } });
      const saveButtons = screen.getAllByText('Save');
      fireEvent.click(saveButtons[saveButtons.length - 1]);
      
      // Now load it
      const select = screen.getByRole('combobox');
      fireEvent.change(select, { target: { value: 'My Sound' } });
      
      expect(mockPresetManager.loadPreset).toHaveBeenCalledWith(
        expect.objectContaining({ name: 'My Sound' })
      );
    });

    it('should display user presets list section after saving', () => {
      renderWithContext(<PresetPanel />);
      
      // Initially no user presets section
      expect(screen.queryByText('Your Presets')).not.toBeInTheDocument();
      
      // Save a preset
      fireEvent.click(screen.getByText('Save Current'));
      const input = screen.getByPlaceholderText('Preset name...');
      fireEvent.change(input, { target: { value: 'Test Preset' } });
      const saveButtons = screen.getAllByText('Save');
      fireEvent.click(saveButtons[saveButtons.length - 1]);
      
      // Now it should appear
      expect(screen.getByText('Your Presets')).toBeInTheDocument();
    });

    it('should render delete button for each user preset', () => {
      renderWithContext(<PresetPanel />);
      
      // Save two presets
      fireEvent.click(screen.getByText('Save Current'));
      let input = screen.getByPlaceholderText('Preset name...');
      fireEvent.change(input, { target: { value: 'Preset 1' } });
      let saveButtons = screen.getAllByText('Save');
      fireEvent.click(saveButtons[saveButtons.length - 1]);
      
      fireEvent.click(screen.getByText('Save Current'));
      input = screen.getByPlaceholderText('Preset name...');
      fireEvent.change(input, { target: { value: 'Preset 2' } });
      saveButtons = screen.getAllByText('Save');
      fireEvent.click(saveButtons[saveButtons.length - 1]);
      
      const deleteButtons = screen.getAllByText('×');
      expect(deleteButtons).toHaveLength(2);
    });
  });

  describe('Save Preset Dialog', () => {
    it('should not show save dialog initially', () => {
      renderWithContext(<PresetPanel />);
      
      expect(screen.queryByText('Save Preset')).not.toBeInTheDocument();
    });

    it('should open save dialog when Save Current clicked', () => {
      renderWithContext(<PresetPanel />);
      
      const saveButton = screen.getByText('Save Current');
      fireEvent.click(saveButton);
      
      expect(screen.getByText('Save Preset')).toBeInTheDocument();
    });

    it('should render input field in save dialog', () => {
      renderWithContext(<PresetPanel />);
      
      fireEvent.click(screen.getByText('Save Current'));
      
      const input = screen.getByPlaceholderText('Preset name...');
      expect(input).toBeInTheDocument();
    });

    it('should render Save and Cancel buttons in dialog', () => {
      renderWithContext(<PresetPanel />);
      
      fireEvent.click(screen.getByText('Save Current'));
      
      const buttons = screen.getAllByText('Save');
      expect(buttons.length).toBeGreaterThanOrEqual(1);
      expect(screen.getByText('Cancel')).toBeInTheDocument();
    });

    it('should close dialog when Cancel clicked', () => {
      renderWithContext(<PresetPanel />);
      
      fireEvent.click(screen.getByText('Save Current'));
      expect(screen.getByText('Save Preset')).toBeInTheDocument();
      
      fireEvent.click(screen.getByText('Cancel'));
      expect(screen.queryByText('Save Preset')).not.toBeInTheDocument();
    });

    it('should save preset with entered name', () => {
      renderWithContext(<PresetPanel />);
      
      fireEvent.click(screen.getByText('Save Current'));
      
      const input = screen.getByPlaceholderText('Preset name...');
      fireEvent.change(input, { target: { value: 'New Sound' } });
      
      const saveButtons = screen.getAllByText('Save');
      const dialogSaveButton = saveButtons[saveButtons.length - 1];
      fireEvent.click(dialogSaveButton);
      
      expect(mockPresetManager.savePreset).toHaveBeenCalledWith('New Sound', 'User');
    });

    it('should show alert on successful save', () => {
      renderWithContext(<PresetPanel />);
      
      fireEvent.click(screen.getByText('Save Current'));
      
      const input = screen.getByPlaceholderText('Preset name...');
      fireEvent.change(input, { target: { value: 'Test' } });
      
      const saveButtons = screen.getAllByText('Save');
      fireEvent.click(saveButtons[saveButtons.length - 1]);
      
      expect(window.alert).toHaveBeenCalledWith('Preset "Test" saved successfully!');
    });

    it('should close dialog after successful save', () => {
      renderWithContext(<PresetPanel />);
      
      fireEvent.click(screen.getByText('Save Current'));
      
      const input = screen.getByPlaceholderText('Preset name...');
      fireEvent.change(input, { target: { value: 'Test' } });
      
      const saveButtons = screen.getAllByText('Save');
      fireEvent.click(saveButtons[saveButtons.length - 1]);
      
      expect(screen.queryByText('Save Preset')).not.toBeInTheDocument();
    });

    it('should not save preset with empty name', () => {
      renderWithContext(<PresetPanel />);
      
      fireEvent.click(screen.getByText('Save Current'));
      
      const saveButtons = screen.getAllByText('Save');
      fireEvent.click(saveButtons[saveButtons.length - 1]);
      
      expect(mockPresetManager.savePreset).not.toHaveBeenCalled();
    });

    it('should trim whitespace from preset name', () => {
      renderWithContext(<PresetPanel />);
      
      fireEvent.click(screen.getByText('Save Current'));
      
      const input = screen.getByPlaceholderText('Preset name...');
      fireEvent.change(input, { target: { value: '  Spaced  ' } });
      
      const saveButtons = screen.getAllByText('Save');
      fireEvent.click(saveButtons[saveButtons.length - 1]);
      
      expect(mockPresetManager.savePreset).toHaveBeenCalledWith('Spaced', 'User');
    });

    it('should save preset on Enter key press', () => {
      renderWithContext(<PresetPanel />);
      
      fireEvent.click(screen.getByText('Save Current'));
      
      const input = screen.getByPlaceholderText('Preset name...');
      fireEvent.change(input, { target: { value: 'Quick Save' } });
      fireEvent.keyDown(input, { key: 'Enter' });
      
      expect(mockPresetManager.savePreset).toHaveBeenCalledWith('Quick Save', 'User');
    });
  });

  describe('Delete Preset', () => {
    it('should show confirmation dialog when delete clicked', () => {
      renderWithContext(<PresetPanel />);
      
      // Save a preset first
      fireEvent.click(screen.getByText('Save Current'));
      const input = screen.getByPlaceholderText('Preset name...');
      fireEvent.change(input, { target: { value: 'To Delete' } });
      const saveButtons = screen.getAllByText('Save');
      fireEvent.click(saveButtons[saveButtons.length - 1]);
      
      const deleteButton = screen.getByText('×');
      fireEvent.click(deleteButton);
      
      expect(window.confirm).toHaveBeenCalledWith('Delete preset "To Delete"?');
    });

    it('should delete preset when confirmed', () => {
      renderWithContext(<PresetPanel />);
      
      // Save a preset first
      fireEvent.click(screen.getByText('Save Current'));
      const input = screen.getByPlaceholderText('Preset name...');
      fireEvent.change(input, { target: { value: 'To Delete' } });
      const saveButtons = screen.getAllByText('Save');
      fireEvent.click(saveButtons[saveButtons.length - 1]);
      
      const deleteButton = screen.getByText('×');
      fireEvent.click(deleteButton);
      
      expect(mockPresetManager.deletePreset).toHaveBeenCalledWith('To Delete');
    });

    it('should not delete preset when cancelled', () => {
      vi.spyOn(window, 'confirm').mockReturnValue(false);
      
      renderWithContext(<PresetPanel />);
      
      // Save a preset first
      fireEvent.click(screen.getByText('Save Current'));
      const input = screen.getByPlaceholderText('Preset name...');
      fireEvent.change(input, { target: { value: 'Keep Me' } });
      const saveButtons = screen.getAllByText('Save');
      fireEvent.click(saveButtons[saveButtons.length - 1]);
      
      const deleteButton = screen.getByText('×');
      fireEvent.click(deleteButton);
      
      expect(mockPresetManager.deletePreset).not.toHaveBeenCalled();
    });

    it('should clear selected preset if deleting currently selected', () => {
      renderWithContext(<PresetPanel />);
      
      // Save a preset first
      fireEvent.click(screen.getByText('Save Current'));
      const input = screen.getByPlaceholderText('Preset name...');
      fireEvent.change(input, { target: { value: 'Selected' } });
      const saveButtons = screen.getAllByText('Save');
      fireEvent.click(saveButtons[saveButtons.length - 1]);
      
      // Select the preset
      const select = screen.getByRole('combobox') as HTMLSelectElement;
      fireEvent.change(select, { target: { value: 'Selected' } });
      expect(select.value).toBe('Selected');
      
      // Delete it
      const deleteButton = screen.getByText('×');
      fireEvent.click(deleteButton);
      
      expect(select.value).toBe('');
    });
  });

  describe('Export Preset', () => {
    it('should export current preset when Export clicked', () => {
      // Mock document.createElement to capture the anchor element
      let anchorClicked = false;
      const originalCreateElement = document.createElement.bind(document);
      
      vi.spyOn(document, 'createElement').mockImplementation((tagName: string) => {
        const element = originalCreateElement(tagName);
        if (tagName === 'a') {
          element.click = () => { anchorClicked = true; };
        }
        return element;
      });
      
      renderWithContext(<PresetPanel />);
      
      const exportButton = screen.getByText('Export');
      fireEvent.click(exportButton);
      
      expect(mockPresetManager.getCurrentPreset).toHaveBeenCalled();
      expect(mockPresetManager.exportPreset).toHaveBeenCalled();
      expect(anchorClicked).toBe(true);
      
      vi.restoreAllMocks();
    });

    it('should create blob with JSON content', () => {
      let anchorClicked = false;
      const originalCreateElement = document.createElement.bind(document);
      
      vi.spyOn(document, 'createElement').mockImplementation((tagName: string) => {
        const element = originalCreateElement(tagName);
        if (tagName === 'a') {
          element.click = () => { anchorClicked = true; };
        }
        return element;
      });
      
      renderWithContext(<PresetPanel />);
      
      const exportButton = screen.getByText('Export');
      fireEvent.click(exportButton);
      
      // Verify JSON export was called
      expect(mockPresetManager.exportPreset).toHaveBeenCalledWith(
        expect.objectContaining({ name: 'Current' })
      );
      
      vi.restoreAllMocks();
    });

    it('should trigger download with correct filename format', () => {
      renderWithContext(<PresetPanel />);
      
      const exportButton = screen.getByText('Export');
      fireEvent.click(exportButton);
      
      expect(URL.createObjectURL).toHaveBeenCalled();
    });
  });

  describe('Import Preset', () => {
    it('should trigger file input when Import clicked', () => {
      const clickSpy = vi.fn();
      const originalCreateElement = document.createElement.bind(document);
      
      vi.spyOn(document, 'createElement').mockImplementation((tagName: string) => {
        const element = originalCreateElement(tagName);
        if (tagName === 'input') {
          element.click = clickSpy;
        }
        return element;
      });
      
      renderWithContext(<PresetPanel />);
      
      const importButton = screen.getByText('Import');
      fireEvent.click(importButton);
      
      expect(clickSpy).toHaveBeenCalled();
      
      vi.restoreAllMocks();
    });

    it('should accept only JSON files', () => {
      let capturedInput: HTMLInputElement | null = null;
      const originalCreateElement = document.createElement.bind(document);
      
      vi.spyOn(document, 'createElement').mockImplementation((tagName: string) => {
        const element = originalCreateElement(tagName);
        if (tagName === 'input') {
          capturedInput = element as HTMLInputElement;
        }
        return element;
      });
      
      renderWithContext(<PresetPanel />);
      
      const importButton = screen.getByText('Import');
      fireEvent.click(importButton);
      
      expect(capturedInput).not.toBeNull();
      expect(capturedInput!.accept).toBe('.json');
      
      vi.restoreAllMocks();
    });
  });

  describe('Component Integration', () => {
    it('should work without onPresetLoad callback', () => {
      renderWithContext(<PresetPanel />);
      
      const select = screen.getByRole('combobox');
      
      expect(() => {
        fireEvent.change(select, { target: { value: 'Init' } });
      }).not.toThrow();
    });

    it('should update user presets list after save', () => {
      renderWithContext(<PresetPanel />);
      
      // Initially no user presets
      expect(screen.queryByText('Your Presets')).not.toBeInTheDocument();
      
      // Save a preset
      fireEvent.click(screen.getByText('Save Current'));
      const input = screen.getByPlaceholderText('Preset name...');
      fireEvent.change(input, { target: { value: 'New' } });
      const saveButtons = screen.getAllByText('Save');
      fireEvent.click(saveButtons[saveButtons.length - 1]);
      
      // Now user presets section should appear
      expect(screen.getByText('Your Presets')).toBeInTheDocument();
    });

    it('should handle empty preset selection', () => {
      renderWithContext(<PresetPanel />);
      
      const select = screen.getByRole('combobox');
      
      fireEvent.change(select, { target: { value: '' } });
      
      expect(mockPresetManager.loadPreset).not.toHaveBeenCalled();
    });

    it('should handle save error gracefully', () => {
      const errorManager = createMockPresetManager();
      errorManager.savePreset = vi.fn(() => {
        throw new Error('Storage full');
      });
      const errorEngine = createMockSynthEngine(errorManager);
      
      renderWithContext(<PresetPanel />, errorEngine);
      
      fireEvent.click(screen.getByText('Save Current'));
      const input = screen.getByPlaceholderText('Preset name...');
      fireEvent.change(input, { target: { value: 'Test' } });
      const saveButtons = screen.getAllByText('Save');
      fireEvent.click(saveButtons[saveButtons.length - 1]);
      
      expect(window.alert).toHaveBeenCalledWith(expect.stringContaining('Error saving preset'));
    });
  });
});
